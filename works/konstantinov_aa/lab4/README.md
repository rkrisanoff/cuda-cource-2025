# Оптимизированная поразрядная сортировка (Radix Sort) на CUDA

В данном проекте реализована высокопроизводительная версия алгоритма **Radix Sort** для сортировки 32-битных и 64-битных целых чисел на GPU.


---

## Ключевые оптимизации и "Почему так?"

### 1. Radix-256 (8 бит за проход)
Вместо стандартного Radix-16 (4 бита), мы используем основание 256.
*   **Почему:** Это сокращает количество проходов по памяти в 2 раза.
    *   *32-битные числа:* 4 прохода (вместо 8).
    *   *64-битные числа:* 8 проходов (вместо 16).
*   **Код:** Константы `RADIX_BITS = 8` и `RADIX = 256` (строки 23-27).

### 2. Warp Shuffle Instructions (Самое важное!)
Для вычисления префиксных сумм (Scan) мы не используем Shared Memory, а используем инструкции `__shfl_up_sync`.
*   **Код:** Функция `warp_inclusive_scan` (строки 39-47).
*   **Почему это быстрее:**
    *   **Нет обращения к памяти:** Данные передаются напрямую между регистрами потоков внутри одного варпа (32 потока). Это занимает 1 такт, в то время как Shared Memory — ~20-30 тактов.
    *   **Нет барьеров:** Нам не нужно делать `__syncthreads()`, так как варп синхронен по своей природе.
*   **Как это работает:**
    ```cpp
    // Поток i берет значение у потока i - delta
    unsigned int temp = __shfl_up_sync(mask, val, delta);
    ```
    Это используется в ядрах `prescan_kernel` и `prescan_finalize` для молниеносного сканирования.

### 3. Поддержка знаковых чисел (Signed Integers)
Radix Sort по природе умеет работать только с беззнаковыми битами. Отрицательные числа (начинающиеся с 1) он считает "большими".
*   **Трюк:** Мы инвертируем старший (знаковый) бит перед сортировкой.
    *   `MIN_INT` (-2млрд) становится `0`.
    *   `MAX_INT` (+2млрд) становится `MAX_UINT`.
*   **Код:** Строки 293-294 в функции `run_test`:
    ```cpp
    UnsignedT sign_mask = (UnsignedT)1 << (sizeof(T) * 8 - 1);
    hu[i] = ((UnsignedT)h[i]) ^ sign_mask; // XOR переворачивает бит
    ```
    После сортировки мы делаем XOR еще раз, возвращая исходные значения.

---

## Детальный разбор 4-х этапов сортировки

Сортировка происходит в цикле `for (int shift = 0; shift < num_bits; ...)` (функция `radix_sort`).
На каждой итерации (для текущего байта) выполняются 4 шага:

### Шаг 1: Подсчет статистики (Histogram)
**Ядро:** `histogram_kernel` (строки 66-85)
**Паттерн:** Map + Reduce

1.  **Задача:** Узнать, сколько раз каждая цифра (0..255) встречается в каждом блоке.
2.  **Реализация:**
    *   Каждый поток читает элемент и выделяет байт: `get_digit(...)`.
    *   Использует **Shared Memory** (`local_hist`) для подсчета.
    *   Использует `atomicAdd` для безопасного инкремента.
3.  **Хитрость (Транспонирование):**
    В конце (строка 83) мы пишем результат в глобальную память **по столбцам**:
    ```cpp
    d_counters[tid * num_blocks + blockIdx.x] = local_hist[tid];
    ```
    Это группирует счетчики для одной цифры (со всех блоков) в непрерывный массив, что критически важно для скорости следующего шага.

### Шаг 2: Расчет смещений (Prescan)
**Ядро:** `prescan_kernel` (строки 97-146)
**Паттерн:** Parallel Scan

1.  **Задача:** Превратить "количества" в "адреса записи" для каждого блока.
2.  **Параллелизм:** Мы запускаем ровно 256 блоков (`gridSize = RADIX`).
    *   Блок №5 обрабатывает только цифру "5".
3.  **Реализация:**
    *   Блок сканирует массив счетчиков для своей цифры.
    *   Используется **иерархический скан**:
        *   Сначала `warp_inclusive_scan` (на регистрах).
        *   Потом скан сумм варпов в Shared Memory.
        *   Потом добавление глобального `carry`.

### Шаг 3: Глобальные границы (Finalize)
**Ядро:** `prescan_finalize` (строки 149-178)
**Паттерн:** Scan

1.  **Задача:** Узнать глобальный старт для каждой цифры.
    *   Если нулей всего 1000, то единицы должны начинаться с индекса 1000.
2.  **Реализация:** Простой скан массива из 256 элементов (тоталов) в одном блоке.

### Шаг 4: Перемещение данных (Scatter)
**Ядро:** `scatter_kernel` (строки 186-230)
**Паттерн:** Map + Local Scan + Scatter

1.  **Задача:** Физически переместить элементы на новые места.
2.  **Проблема:** Как сохранить порядок одинаковых элементов (Стабильность)?
3.  **Решение (Local Rank):**
    *   Поток снова читает цифру элемента.
    *   Он смотрит на своих соседей слева (внутри блока) и считает: "Сколько таких же цифр встретилось *до меня*?".
    *   **Код (строки 218-220):**
        ```cpp
        for (int i = 0; i < tid; ++i) {
             if (s_digits[i] == digit) local_rank++;
        }
        ```
    *   Это значение `local_rank` гарантирует, что порядок сохранится.
4.  **Запись:**
    `GlobalPos = Base + BlockOffset + LocalRank`.

---

## Результаты производительности

Тесты проведены на массиве из **16,777,216 элементов** (N = 2^24).

### 32-bit Integer (`int`)
```text
Time CPU std::sort: ~1.18 s
Time GPU Custom:    ~0.09 s
Time GPU Thrust:    ~0.08 s

```

### 64-bit Integer (`long long`)
```text
Time CPU std::sort: ~1.45 s
Time GPU Custom:    ~0.18 s (в 2 раза дольше из-за 8 байт)
Time GPU Thrust:    ~0.16 s

```


