# Lab 4: Radix Sort

## Описание

В данной лабораторной работе реализован алгоритм поразрядной сортировки (Radix Sort) для массивов знаковых целых чисел (с поддержкой отрицательных чисел) с использованием CUDA. Алгоритм поддерживает как 32-битные (int32_t), так и 64-битные (int64_t) целые числа.

## Алгоритм

### Общая концепция Radix Sort

Radix Sort — это некомпаративный алгоритм сортировки, который сортирует числа по разрядам (битам), начиная с младших разрядов. Алгоритм обрабатывает числа по 2 бита за раз, что дает 4 возможных значения (0, 1, 2, 3) на каждой итерации. 

- Для **32-битных целых чисел**: выполняется 16 итераций (биты 0-1, 2-3, 4-5, ..., 30-31)
- Для **64-битных целых чисел**: выполняется 32 итерации (биты 0-1, 2-3, 4-5, ..., 62-63)

### Поддержка отрицательных чисел

Для корректной сортировки знаковых целых чисел (включая отрицательные) используется техника инверсии знакового бита:

1. **Перед сортировкой**: инвертируется знаковый бит (31-й бит для 32-битных, 63-й бит для 64-битных чисел)
   - Это преобразует знаковые числа в беззнаковые для сортировки
   - Отрицательные числа становятся больше положительных в беззнаковом представлении
   
2. **После сортировки**: знаковый бит инвертируется обратно
   - Восстанавливаются исходные знаковые значения
   - Результат: отрицательные числа идут перед положительными в отсортированном порядке

### Основные компоненты алгоритма

#### 1. Параллельное префиксное суммирование (Parallel Prefix Sum)

Алгоритм использует префиксное суммирование для определения позиций элементов при перестановке. Реализован алгоритм Blelloch, который состоит из двух фаз:

**Фаза 1: Up-sweep (восходящее сканирование)**
- Строится бинарное дерево сумм снизу вверх
- Каждый узел дерева содержит сумму элементов в поддереве
- Сложность: O(log n) вместо O(n) последовательных операций

**Фаза 2: Down-sweep (нисходящее сканирование)**
- Суммы распространяются обратно к листьям дерева
- Каждый элемент получает сумму всех предыдущих элементов
- Результат: для массива [1, 2, 3, 4] получаем [0, 1, 3, 6]

#### 2. Локальная сортировка внутри блока (local_radix_sort_step)

На каждом шаге Radix Sort выполняется локальная сортировка внутри каждого блока потоков:

1. **Загрузка данных в shared memory** — данные блока загружаются в быструю shared memory
2. **Извлечение цифр** — из каждого числа извлекаются 2 бита текущего разряда (значения 0-3)
3. **Вычисление масок** — для каждой цифры создается маска, показывающая, какие элементы имеют эту цифру
4. **Префиксные суммы масок** — параллельно вычисляются префиксные суммы для каждой цифры
5. **Перестановка элементов** — элементы переставляются в отсортированном порядке внутри блока

**Оптимизации:**
- Все промежуточные вычисления выполняются в shared memory
- Параллельная обработка всех 4 цифр в одном проходе
- Минимизация синхронизаций между потоками

#### 3. Глобальная перестановка данных (global_data_rearrangement)

После локальной сортировки элементы отсортированы внутри каждого блока, но необходимо выполнить глобальную перестановку, чтобы все элементы с цифрой 0 были перед элементами с цифрой 1, и т.д.

**Алгоритм:**
1. Вычисляются префиксные суммы для сумм блоков по каждой цифре
2. Для каждого элемента вычисляется глобальная позиция:
   - Глобальная позиция = смещение для цифры элемента + локальная позиция в блоке
3. Элементы записываются в правильные глобальные позиции

### Основной цикл Radix Sort

Алгоритм выполняет итерации по 2 бита за раз. Количество итераций зависит от размера типа:

- **32-битные числа**: 16 итераций (биты 0-1, 2-3, ..., 30-31)
- **64-битные числа**: 32 итерации (биты 0-1, 2-3, ..., 62-63)

```cpp
// Инверсия знакового бита для поддержки отрицательных чисел
flip_sign_bit(...);

// Основной цикл сортировки
unsigned int max_bit_shift = (sizeof(T) * 8) - 2;
for (unsigned int bit_shift = 0; bit_shift <= max_bit_shift; bit_shift += 2) {
    // 1. Локальная сортировка внутри блоков
    local_radix_sort_step(...);
    
    // 2. Вычисление префиксных сумм для сумм блоков
    parallel_prefix_sum(...);
    
    // 3. Глобальная перестановка элементов
    global_data_rearrangement(...);
}

// Восстановление знакового бита
flip_sign_bit(...);
```

### Преимущества Radix Sort

- **Линейная сложность O(n)** вместо O(n log n) для алгоритмов сравнения
- **Отлично подходит для параллельной обработки** на GPU
- **Стабильная сортировка** — сохраняет порядок равных элементов
- **Предсказуемая производительность** — не зависит от распределения данных

## Компиляция

```bash
make
```

Или вручную:

```bash
nvcc -O3 -arch=sm_75 -std=c++11 -o radix_sort main.cu sort.cu -lcudart
```

## Запуск

```bash
./radix_sort
```

Программа автоматически выполняет тесты на массивах размеров 100000, 500000 и 1000000 элементов.

## Результаты тестирования

### Производительность

```
=================================
Testing int32_t (32-bit integers)
=================================

Array size: 100000
CPU time: 0.009217s
GPU time: 0.002156s
Thrust time: 0.001479s
GPU / CPU: 4.27505x
Thrust / GPU: 1.45774x
Sorting correctness: PASSED


Array size: 500000
CPU time: 0.049057s
GPU time: 0.006308s
Thrust time: 0.000654s
GPU / CPU: 7.77695x
Thrust / GPU: 9.64526x
Sorting correctness: PASSED


Array size: 1000000
CPU time: 0.103827s
GPU time: 0.01186s
Thrust time: 0.000899s
GPU / CPU: 8.75438x
Thrust / GPU: 13.1924x
Sorting correctness: PASSED


=================================
Testing int64_t (64-bit integers)
=================================

Array size: 100000
CPU time: 0.008062s
GPU time: 0.003831s
Thrust time: 0.000363s
GPU / CPU: 2.10441x
Thrust / GPU: 10.5537x
Sorting correctness: PASSED


Array size: 500000
CPU time: 0.044522s
GPU time: 0.012667s
Thrust time: 0.000959s
GPU / CPU: 3.5148x
Thrust / GPU: 13.2086x
Sorting correctness: PASSED


Array size: 1000000
CPU time: 0.077416s
GPU time: 0.023528s
Thrust time: 0.001604s
GPU / CPU: 3.29038x
Thrust / GPU: 14.6683x
Sorting correctness: PASSED
```

### Анализ результатов

#### Производительность для int32_t (32-битные целые числа)

1. **Ускорение GPU относительно CPU**: от 4.3x до 8.8x в зависимости от размера массива
   - Ускорение увеличивается с ростом размера массива благодаря лучшей утилизации GPU
   - Для массива из 1,000,000 элементов достигается ускорение 8.75x

2. **Сравнение с Thrust**: Thrust библиотека показывает лучшее время выполнения
   - Thrust быстрее нашей реализации в 1.5x - 13.2x раз
   - Это ожидаемо, так как Thrust использует высокооптимизированные алгоритмы
   - Наша реализация показывает хорошую производительность и правильность работы

#### Производительность для int64_t (64-битные целые числа)

1. **Ускорение GPU относительно CPU**: от 2.1x до 3.5x в зависимости от размера массива
   - Ускорение меньше, чем для 32-битных чисел, так как требуется в 2 раза больше итераций (32 вместо 16)
   - Для массива из 1,000,000 элементов достигается ускорение 3.29x

2. **Сравнение с Thrust**: Thrust библиотека значительно быстрее
   - Thrust быстрее нашей реализации в 10.6x - 14.7x раз
   - Разница более заметна для 64-битных чисел из-за большего количества итераций

#### Общие наблюдения

3. **Корректность**: Все тесты проходят проверку корректности сортировки
   - Алгоритм корректно обрабатывает как положительные, так и отрицательные числа
   - Поддерживаются оба типа: 32-битные и 64-битные целые числа

4. **Масштабируемость**: Производительность улучшается с увеличением размера массива
   - GPU показывает лучшую эффективность на больших массивах
   - Преимущество GPU над CPU становится более выраженным на больших данных


## Особенности реализации

- Использование алгоритма Blelloch для префиксного суммирования
- Обработка 2 бит за раз
- Поддержка знаковых целых чисел через инверсию знакового бита
- Шаблонная реализация для поддержки как 32-битных (int32_t), так и 64-битных (int64_t) целых чисел
- Автоматическое определение количества итераций в зависимости от размера типа данных
